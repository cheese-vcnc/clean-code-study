# 2주차 4. 주석, 5. 형식 맞추기 (68 ~ 116p)

#### 72p. 의미를 명료하게 밝히는 주석
```text
때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다.
일반적으로는 인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 인수나 반환값이
표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용한다.
```
* 데코레이터 패턴과 같은 패턴을 이용하면 표준 라이브러리나 변경하지 못하는 코드에 속하더라도 주석을 사용하지 않고도 의미를 충분히 전달할 수 있다고 생각한다.

#### 101p. 수직 거리

```text
서로 밀접한 개념은 세로로 가까이 둬야 한다.
```
* 이 개념은 개발을 하면서 많은 도움이 되었던 것 같다. 종속 함수로 나아갈수록 행위에 대해 더 구체적인 맥락으로 함수를 작성하면 좀 더 깔끔하게 코드를 작성할 수 있었던 것 같다. 다른 분들도 이러한 방식으로 하는지 궁금하다.

#### 110p.
```text
정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 아니다.
```
* 공감한다. 하나의 클래스에 대해서 목록이 길어진다면 단위 테스트를 작성하기가 싱당히 어려워진다. 사전에 셋팅해야할 조건들이 복잡해지고 경우의 수가 상당히 많아지기 때문이다.

#### 113p. 팀규칙
```text
프로그래머라면 각자 선호하는 규칙이 있다. 하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.
```
* 제가 속한 팀은 컬렉션 타입에 대한 변수명의 후미에 해당하는 자료구조 이름을 붙이는 편이다. 가령 이런 식이다. val fooList = listOf(Foo("hello"), Foo("world"))
* 저는 코딩을 하면서 해당 변수명으로 인하여 어떤 자료구조의 타입인지 인지하지 못하도록 복수형을 쓰는 편이다. 가령 이런 식이다. val foos = listOf(Foo("hello"), Foo("world"))
  * 이렇게 하는 이유는 개발자들이 필요에 의해 자료구조를 변경하였을 때, 깜빡하고 변수명까지 바꾸지 않아서 개발자에게 잘못된 정보를 전달하지 않도록 방지하기 위해서이다. (사람에 의한 실수를 줄이기 위함)
  * val fooList = listOf(Foo("hello"), Foo("world")) 에서 val fooList = setOf(Foo("hello"), Foo("world")) 자료구조만 바꾸고 변수명을 fooSet으로 바꾸지 않아서 잘못된 정보를 전달할 가능성이 생긴다. * 지난주에 읽었던 내용에서 알아보았듯이 List, Set 은 개발자에게 있어서 특수한 단어이다.
  * 하지만 팀의 방향은 변수명에서 자료구조를 특정할 수 있도록 하는 편이다. 그래서 저도 그런 방식을 따라서 코딩을 한다.